<?php
namespace Framework\Database\Model;

use Framework\Database\SchemaModel;
use Framework\Utils\Arrays;
use Framework\Utils\Strings;

use Attribute;

/**
 * The Relation Attribute
 */
#[Attribute(Attribute::TARGET_PROPERTY)]
class Relation {

    // Name of the Key used in the Schema. Generated by default
    // FIXME: Remove this temporary hack
    public string $key          = "";

    // By default the name of the Model is used, but it can be set if required
    public string $schemaName   = "";

    // By default the name of the Model is used, but if there are multiple Models with the same name,
    // this can be used to specify a different name to be used
    public string $asSchema     = "";

    // By default the join is done to the Model with the property, but it can be done with another Model
    public string $onSchema     = "";

    // Name of the column to do the join in this Model
    // By default the primary key of the Model is used
    public string $myKey        = "";

    // Name of the column to do the join in the other Model
    // By default the primary key of the Model is used
    public string $otherKey     = "";

    // Used when the join requires a secondary condition
    public string $andSchema    = "";

    // Used when the join requires a secondary condition
    public string $andKey       = "";

    // Used when the join requires a secondary condition
    public string $andValue     = "";

    // Used when the join requires a secondary condition
    /** @var string[] */
    public array  $andKeys      = [];

    // Used when the join requires a secondary condition
    public bool   $andDeleted   = false;


    // By default a prefix is added to the field names but it can be disabled
    public bool  $withPrefix    = true;

    // The prefix to be used for the fields. By default it uses the name of the property
    public string $prefix       = "";


    // Allows to use the 'isDeleted' field of the Model. Is not required when using the fieldNames
    public bool  $withDeleted   = false;

    // By default all fields are returned but this allows to specify a list of field names
    /** @var string[] */
    public array $fieldNames    = [];

    // Allows to specify which fields should be returned without the prefix
    /** @var string[] */
    public array $withoutPrefix = [];


    // Used internally when parsing the Model
    public ?SchemaModel $relatedModel = null;
    public ?SchemaModel $parentModel  = null;

    /** @var Field[] */
    public array $fields = [];



    /**
     * The Relation Attribute
     * @param string   $schemaName    Optional.
     * @param string   $asSchema      Optional.
     * @param string   $onSchema      Optional.
     * @param string   $key           Optional.
     * @param string   $myKey         Optional.
     * @param string   $otherKey      Optional.
     * @param string   $andSchema     Optional.
     * @param string   $andKey        Optional.
     * @param string   $andValue      Optional.
     * @param string[] $andKeys       Optional.
     * @param boolean  $andDeleted    Optional.
     * @param boolean  $withPrefix    Optional.
     * @param string   $prefix        Optional.
     * @param boolean  $withDeleted   Optional.
     * @param string[] $fieldNames    Optional.
     * @param string[] $withoutPrefix Optional.
     */
    public function __construct(
        string $schemaName    = "",
        string $asSchema      = "",
        string $onSchema      = "",
        string $key           = "",
        string $myKey         = "",
        string $otherKey      = "",
        string $andSchema     = "",
        string $andKey        = "",
        string $andValue      = "",
        array  $andKeys       = [],
        bool   $andDeleted    = false,
        bool   $withPrefix    = true,
        string $prefix        = "",
        bool   $withDeleted   = false,
        array  $fieldNames    = [],
        array  $withoutPrefix = [],
    ) {
        $this->schemaName    = $schemaName;
        $this->asSchema      = $asSchema;
        $this->onSchema      = $onSchema;
        $this->key           = $key;
        $this->myKey         = $myKey;
        $this->otherKey      = $otherKey;

        $this->andSchema     = $andSchema;
        $this->andKey        = $andKey;
        $this->andValue      = $andValue;
        $this->andKeys       = $andKeys;
        $this->andDeleted    = $andDeleted;

        $this->withPrefix    = $withPrefix;
        $this->prefix        = $prefix;
        $this->withDeleted   = $withDeleted;
        $this->fieldNames    = $fieldNames;
        $this->withoutPrefix = $withoutPrefix;
    }



    /**
     * Sets the Data from the Model
     * @param string $schemaName
     * @param string $prefix
     * @return Relation
     */
    public function setData(string $schemaName, string $prefix): Relation {
        if ($this->schemaName === "") {
            $this->schemaName = $schemaName;
        }
        if ($this->prefix === "") {
            $this->prefix = $prefix;
        }
        return $this;
    }

    /**
     * Sets the Model for the Relation and creates the fields
     * @param SchemaModel $relatedModel
     * @param SchemaModel $parentModel
     * @return Relation
     */
    public function setModel(SchemaModel $relatedModel, SchemaModel $parentModel): Relation {
        $this->relatedModel = $relatedModel;
        $this->parentModel  = $parentModel;

        $withTimestamps = Arrays::contains($this->fieldNames, [ "createdTime", "modifiedTime" ], atLeastOne: true);
        $withDeleted    = $this->withDeleted || Arrays::contains($this->fieldNames, "isDeleted");
        $fields         = $relatedModel->getFields($withTimestamps, $withDeleted);
        $parentFields   = $parentModel->getFields(true, true);
        $hasFields      = count($this->fieldNames) > 0;

        foreach ($fields as $field) {
            if ($field->isID) {
                continue;
            }

            $fieldName  = $field->dbName;
            $prefixName = $fieldName;
            if ($this->withPrefix) {
                $prefixName = $this->prefix . Strings::upperCaseFirst($fieldName);
            }

            if ($hasFields && !Arrays::contains($this->fieldNames, $field->name)) {
                continue;
            }
            if (!$hasFields && Arrays::contains($parentFields, $prefixName)) {
                continue;
            }

            if ($this->withPrefix && !Arrays::contains($parentFields, $fieldName) && (
                $field->isSchemaID() ||
                Strings::startsWith($field->name, $this->prefix) ||
                Arrays::contains($this->withoutPrefix, $field->name)
            )) {
                $field->noPrefix = true;
                $prefixName      = $fieldName;
            }

            $field->prefixName = $prefixName;
            $this->fields[]    = $field;
        }

        return $this;
    }

    /**
     * Returns the fields from the Model
     * @return Field[]
     */
    public function getFields(): array {
        if ($this->relatedModel === null) {
            return [];
        }

        $withTimestamps = Arrays::contains($this->fieldNames, [ "createdTime", "modifiedTime" ], atLeastOne: true);
        $withDeleted    = $this->withDeleted || Arrays::contains($this->fieldNames, "isDeleted");
        return $this->relatedModel->getFields($withTimestamps, $withDeleted);
    }

    /**
     * Returns the Name of the ID Field
     * @return string
     */
    public function getKey(): string {
        if ($this->key !== "") {
            return Field::generateKey($this->key);
        }
        if ($this->myKey !== "") {
            return Field::generateKey($this->myKey);
        }
        if ($this->relatedModel !== null) {
            return $this->relatedModel->idKey;
        }
        return "";
    }

    /**
     * Returns the Name of the Table
     * @return string
     */
    public function getTableName(): string {
        $schemaName = $this->schemaName;
        if ($this->asSchema !== "") {
            $schemaName = $this->asSchema;
        }
        return SchemaModel::getTableName($schemaName);
    }

    /**
     * Returns the Data as an Array
     * @return array<string,mixed>
     */
    public function toArray(): array {
        if ($this->relatedModel === null) {
            return [];
        }

        $fields = [];
        foreach ($this->fields as $field) {
            $fieldData = [ "type" => $field->type->getName() ];
            if ($field->noPrefix) {
                $fieldData["noPrefix"] = true;
            }
            if ($field->decimals !== 2) {
                $fieldData["decimals"] = $field->decimals;
            }

            $fields[$field->name] = $fieldData;
        }

        $result = [
            "schema" => $this->schemaName,
            "fields" => $fields,
        ];

        if ($this->asSchema !== "") {
            $result["asSchema"] = $this->asSchema;
        }
        if ($this->onSchema !== "") {
            $result["onSchema"] = $this->onSchema;
        }

        if ($this->myKey !== "") {
            $result["rightKey"] = Field::generateKey($this->myKey);
        }
        if ($this->otherKey !== "") {
            $result["leftKey"] = Field::generateKey($this->otherKey);
        }

        if ($this->andSchema !== "") {
            $result["andSchema"] = $this->andSchema;
        }
        if ($this->andKey !== "") {
            $result["andKey"] = Field::generateKey($this->andKey);
        }
        if ($this->andValue !== "") {
            $result["andValue"] = Field::generateKey($this->andValue);
        }
        if (count($this->andKeys) > 0) {
            $result["andKeys"] = array_map(fn($key) => Field::generateKey($key), $this->andKeys);
        }
        if ($this->andDeleted) {
            $result["andDeleted"] = true;
        }

        if ($this->withPrefix) {
            $result["prefix"] = $this->prefix;
        }
        return $result;
    }
}
